require "csv"

class SurveyResponse < ApplicationRecord
  belongs_to :survey

  # This is a UUID supplied by the user that uniquely and anonymously identifies them.
  # It is expected to be generated by and stored on the user's device.
  validates :user_identifier, presence: true

  # This is a UUID that is generated by the server and is used to publicly identify the response.
  # We expose UUIDs publicly instead of the id field to avoid insecure direct object reference attacks
  # and leaking information about the number of responses.
  validates :public_identifier, presence: true

  validates :stop_identifier, presence: true, if: -> { survey.require_stop_id_in_response? }

  after_initialize do
    self.public_identifier ||= SecureRandom.hex(10)
  end

  def to_param
    public_identifier
  end

  # Response Data

  attribute :responses, SurveyResponseContent.to_array_type

  # Merges new responses into the existing responses. If a response with the same question_id already exists,
  # it will be replaced with the new response. If a response with the same question_id does not exist, it will be added.
  # This method does not save the record.
  # @param new_responses [Array<SurveyResponseContent>] The new responses to merge into the existing responses.
  def upsert_responses(new_responses)
    new_response_dictionary = new_responses.index_by(&:question_id)
    current_response_dictionary = responses&.index_by(&:question_id) || {}
    all_keys = new_response_dictionary.keys | current_response_dictionary.keys

    self.responses = all_keys.map do |key|
      new_response_dictionary[key] || current_response_dictionary[key]
    end
  end

  # Merges new responses into the existing responses. If a response with the same question_id already exists,
  # it will be replaced with the new response. If a response with the same question_id does not exist, it will be added.
  # This method calls save! on self.
  # @param new_responses [Array<SurveyResponseContent>] The new responses to merge into the existing responses.
  def upsert_responses!(new_responses)
    upsert_responses(new_responses)
    save!
  end

  # Helper method to generate CSV
  def self.to_csv(survey_responses)
    all_question_labels = extract_question_labels(survey_responses)

    CSV.generate(headers: true) do |csv|
      csv << csv_header(all_question_labels)

      survey_responses.each do |response|
        csv << build_row(response, all_question_labels)
      end
    end
  end

  # Extracts all question labels from all responses
  def self.extract_question_labels(survey_responses)
    survey_responses.flat_map do |response|
      response.responses.map(&:question_label).compact
    end.uniq
  end

  # Generates a CSV header
  def self.csv_header(all_question_labels)
    ["ID", "User ID", "Stop", "Stop latitude", "Stop longitude", "Created"] + all_question_labels
  end

  # Generates a CSV row
  def self.build_row(response, all_question_labels)
    answer_hash = build_answer_hash(response)

    row = [
      response.id,
      response.user_identifier,
      response.stop_identifier,
      response.stop_latitude,
      response.stop_longitude,
      response.created_at
    ]

    all_question_labels.each do |label|
      row << (answer_hash[label] || "")
    end

    row
  end

  # Builds a hash of question labels to their answers
  def self.build_answer_hash(response)
    response.responses.each_with_object({}) do |r, h|
      question_label = r.question_label || "Unknown Label"
      h[question_label] = parse_answer(r)
    end
  end

  # Parses the answer based on the question type
  def self.parse_answer(response)
    case response.question_type
    when 'checkbox'
      parse_checkbox_answer(response.answer)
    when 'radio', 'text'
      response.answer
    else
      response.answer || ""
    end
  end

  # Parses checkbox answers into a comma-separated string
  def self.parse_checkbox_answer(answer)
    parsed_answer = answer.gsub(/[\[\]]/, '')
    parsed_answer.split(',').map(&:strip).join(', ')
  end
end
